local PathGen = {
    pathPoint = {},
}

function PathGen:Awake()
    self:InitPath()
    self:DrawPath()
end

function PathGen:OnEnable()
    self:InitPath()
    self:DrawPath()
end

function PathGen:InitPath()
    self.pathPoint = {}
    local transList = self.pathNode:GetComponentsInChildren(typeof(UE.Transform))
    local midPoints = {}
    local point = nil
    local max = transList.Length - 1
    for i = 0, max do
        if i < max then
            point = (transList[i].position + transList[i + 1].position) / 2
            table.insert(midPoints, point)
        else
            point = (transList[i].position + transList[0].position) / 2
            table.insert(midPoints, point)
        end
    end
    
    local dis = 0
    for i = 0, max do
        if i < max then
            dis = UE.Vector3.Distance(transList[i].position, transList[i + 1].position)
        else
            dis = UE.Vector3.Distance(transList[i].position, transList[0].position)
        end
        local count = math.ceil(dis)
        local bezier = CL.Bezier(count > 0 and count or 3)
        local prevIdx = i == 0 and #midPoints or i
        local nextIdx = i % #midPoints + 1
        local pointList = bezier:GetQuadraticCurvePoints(midPoints[prevIdx], transList[i].position, midPoints[nextIdx])
        for j = 0, pointList.Length - 1 do
            table.insert(self.pathPoint, pointList[j])
        end
    end
end

function PathGen:DrawPath()
    self.lineRenderer.positionCount = #self.pathPoint
    for k, v in ipairs(self.pathPoint) do
        self.lineRenderer:SetPosition(k - 1, v)
    end
end

return Class(nil, nil, PathGen)